#!/bin/bash

# buttons

CANCEL_BTN="1"
CLOSE_BTN="252"
OK_BTN="0"

# menu options

DEFAULT_TITLE="Genesi i.MX53 Hardware Tests"
MAIN_MENU="--title=${DEFAULT_TITLE} --list --print-column=2 --column=icon:IMG --column=Test --column=Status --column=@fore@"
FEEDBACK_MENU="--list --column=:RD --column=Status --column=Action:HD"

# general functions

txtmenu_from_file()
{
	local file=${1}
	local title=${2}

	if [ -z "${title}" ]
	then
		title="${DEFAULT_TITLE}"
	fi

	yad --title="${title}" --text="$(cat ${file})"
}

ask_continue()
{
	local btn=$? # TODO UGLY!

	if close_menu ${btn}
	then
		exit 1
	fi
}

if_failure()
{
	local stat=${1}

	if [ "${stat}" = "Failure" ]
	then
		yad --text="The previous test ended in failure. Would you like to continue?"
		return $?
	else
		return 0
	fi
}

progress_view_deprc()
{
	local ttime=${1}
	local title=${2}
	local text=${3}

	if [ -z "${title}" ]
	then
		title="${DEFAULT_TITLE}"
	fi
	
	if [ -z "${text}" ]
	then
		text="Test in progress. Please wait."
	fi

	for i in $(seq 1 $ttime)
	do
		sleep 1
		echo "100*${i}/${ttime}" | bc -l
	done | yad --title="${title}" --progress --auto-close --text="${text}"

}

progress_view_dummy()
{
	local ttime=${1}
	local opts="$@"

	for i in $(seq 1 $ttime)
	do
		sleep 1
		echo ""
	done | progress_view ${ttime} "" "" ${opts}
}

progress_view()
{
	local ttime=${1}
	local title=${2}
	local text=${3}
	
	shift 3

	local opts="$@"

	local start_time=${SECONDS}

    if [ -z "${title}" ]
    then
        title="${DEFAULT_TITLE}"
    fi

    if [ -z "${text}" ]
    then
        text="Test in progress. Please wait."
    fi

	while read line
	do
		if [ ! -z "${line}" ] # coming from dummy
		then
			echo "#${line}" | tee -a ./log # dirty but gets the job done
		fi

		echo "100 * (${SECONDS} - ${start_time}) / ${ttime}" | bc -l
	done | yad --title="${title}" --progress --text="${text}" ${opts}
}

# when time unknown but on step complete can read from stdin
progress_view_steps()
{
	local steps=${1}
	local title=${2}
	local text=${3}
	
	shift 3

	local opts="$@"

	local start_time=${SECONDS}

    if [ -z "${title}" ]
    then
        title="${DEFAULT_TITLE}"
    fi

    if [ -z "${text}" ]
    then
        text="Test in progress. Please wait."
    fi

	for i in $(seq 1 ${steps})
	do
		read line
		#echo "#${line}" | cut -c 1-100 | tee -a ./log # still dirty, still working
		echo "100 * (${i} / ${steps})" | bc -l
	done | yad --title="${title}" --progress --text="${text}" ${opts}
}

progress_view_live_deprc()
{
	local title=${2}
	local text=${3}

	if [ -z "${title}" ]
	then
		title="${DEFAULT_TITLE}"
	fi
	
	if [ -z "${text}" ]
	then
		text="Test in progress. Please wait."
	fi

	while read line
	do
		echo "#${line}"
	done | yad --title="${title}" --progress --autoclose --text="${text}" --enable-log > /dev/null 2>&1
}

continue_after_failure()
{
	local stat=${1}
	local res=0

	if [ ${stat} = "Failure" ]
	then
	    res=$(yad --text="The previoius test ended in failure. Would you like to continue?")
	fi

	return ${res}
}

# TODO not linked with the structure of FEEDBACK_MENU at all!
get_feedback_status()
{
	local result="${1}"

	echo $($(echo "${result}" | cut -d "|" -f3))
}

current_status()
{
	oldStat=${1}
	newStat=${2}

	if [ -z "${oldStat}" ]
	then
		echo ${newStat}
	elif [[ "$oldStat" = $newStat  ]]
	then
		echo $oldStat
	else
		echo "Mixed"
	fi
}

close_menu()
{
	btn=${1}

	if [ ${btn} -eq ${OK_BTN} ]
	then
		return 1
	else
		return 0
	fi
}

mk_menu_body()
{
	local file=${1}
	local process=${2}

	if [ -z "${process}" ]
	then
		process="echo"
	fi

	local accum_body=""
	local tmp=""

	while read line
	do
		tmp=$(${process} ${line})
		accum_body="${accum_body} ${tmp}"
	done < ${file}

	echo ${accum_body}
}

parse_item()
{
	local item_num="${1}"
	local menu_result="${2}"

	echo "${menu_result}" | cut -d"|" -f"${item_num}"
}

# logging
init_test_log()
{
	# bad form - implicitly takes logging directory as
	# current directory

	local logfile="$(pwd)/log"

	echo "----------------------------------------" >> ${logfile}
	date >> ${logfile}
	echo "Logging for test $(basename $(pwd))"      >> ${logfile}
}

log()
{
	local msg="${1}"
	local logfile="$(pwd)/log"

	echo -e $(date "+[%H:%M:%S] ${msg}") >> ${logfile}
}

log_default_feedback()
{
	local options_filename="${1}"

	local res=$(yad ${FEEDBACK_MENU} --rest="${options_filename}")

	log "User feedback:\n${res}"
	echo "${res}"
}

log_default_describe_problem()
{
	# TODO generalize to more than 3!

	local form_fields="--field=${1}:CHK FALSE"
	form_fields="${form_fields} --field=${2}:CHK FALSE"
	form_fields="${form_fields} --field=${3}:CHK FALSE"

	local res=$(yad --text="Please select the most appropriate" --form \
${form_fields} \
--field="Leave any additional comments below":TXT)

	log "\nUser asked to describe problem:"
	log "${form_fields}"
	log "${res}"
}

# main menu functions
config_main_menu_item()
{
	local hwtest=${1}
	local status=${2}
	local icon=""
	local color=""

	case ${status} in
		Incomplete)
			color="black"
			icon="none"
			;;
		Failure)
			color="red"
			icon="failure.png"
			;;
		Success)
			color="green"
			icon="success.png"
			;;
		Mixed)
			color="orange"
			icon="mixed.png"
			;;
		*)
			color="purple"
			icon="none"
			;;
	esac

	echo ${icon} ${hwtest} ${status} ${color}
}

update_test_status()
{
	local testName=${1}
	local status=${2}
	local fileName=${3}

	if [ -z "${status}" ]
	then
		exit 0
	fi

	while read line
	do
		if [[ $line == ${testName}* ]]
		then
			echo "${testName} ${status}" >> tmp_menu_file
		else
			echo "${line}" >> tmp_menu_file
		fi
	done < ${fileName}

	mv tmp_menu_file ${fileName}
}
